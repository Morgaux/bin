#!/bin/sh

# https://gitlab.com/morgaux/bin
# @Author:	Morgaux Meyer
# @License:	MIT (C) 2019

##
# A UNIX Daemon template in pure Shell
#
# Although included in the ~/bin directory, it is writen in pure sh and has no
# dependencies on the other sripts in this repository. This template allows any
# arbitrary .sh script to be used as a daemon, simply by placing the contents
# in the main function. This can even be automated with sed to create a copy
# with the main function filled out. Although, helper funtions would need to be
# declared out side of the main().
#
# Obviously, there are many considerations when writing a script or program that
# is run silently in the backgound. While this template attempts to address as
# many of these as possible, the primary goal is to be POSIX compliant, so that
# any existing script can be easily modified, and so that new scripts can be
# writen as freely as possible.
#
# Curently, this template allows for logging all output from main, as well as
# logging explicit messages and even errors. A PID file is used to prevent
# multiple daemons running if the have the same name, however, if an deamonized
# proccess is abruptly ended or killed without first removing the PID file a new
# process can still open and will clain the PID. The procces will cd into the /
# directory after initializing, so that all main() code is run in the filesystem
# root. This prevents filesystems and directories from getting locked by the
# running process, e.g. to unmount a storage device.
#
# The main funtion is left very open and free, and so still requires the author
# to be aware of possible issues that can arise if running in the background.
# Most daemons will block STDIN preventing the process from hangin while waiting
# for user input. Although this is wise, it restricts the use of the author to
# read from input. For this reason, the author is encouraged, but not required,
# to refrain from using STDIN for input from the user/controlling process.
#
# As the main function may contain a single line or thousands, error handling
# and recovery is left to the author. The log, err, and die included funtions
# allow for consistent implementations. log() will write a message to the given
# logfile. err() will clearly log an error message and always return a non zero
# success code for failure pipelines. die() will kill the daemon in the case of
# an unrecoverable error, an clearly log the cause. These functions may be used
# and modified per implementation, however, the serve as a basis on which one
# can build a roubust daemon program.
#
# In keeping with the Suckless Philosophy, all configuration is maintained in
# the source code, however, in contrast, there is no config.sh file. Any minor
# behavioural or functional changes should be added to the configuration section
# as local scope variables. This makes making small changes, such as where the
# log file should be, simple to make and understand.
##



################################################################################
#                              Configuration vars                              #
################################################################################

while [ "$#" -gt 0 ]
do
	case "$1" in
		-f|--fork) # [ TRUE | FALSE ], fork to background, default TRUE
			OPT_FORK="TRUE"
			if [ "$#" -gt 1 ] && \
				( [ "$2" = "TRUE" ] || [ "$2" = "FALSE" ] )
			then
				OPT_FORK="$2"
				shift # shift value if used
			fi
			;;
		-v) # log mesages verbously
			OPT_VERBOSE="TRUE"
			;;
		-e|--exec) # { COMMAND [ ARGS ] }, sets main() command
			shift
			[ "$#" -gt 0 ] || die "$1 takes an argument, none found"
			EXEC_CMD="$*"
			break
			;;
		--prefix) # { DIR }, sets PREFIX directory
			shift
			[ "$#" -gt 0 ] || die "$1 takes an argument, none found"
			PREFIX="$1"
			;;
		--name) # { NAME }, sets SELF
			shift
			[ "$#" -gt 0 ] || die "$1 takes an argument, none found"
			SELF="$1"
			;;
		--tmp) # { DIR }, sets TMP_DIR
			shift
			[ "$#" -gt 0 ] || die "$1 takes an argument, none found"
			TMP_DIR="$1"
			;;
		*) # option not used by daemon wrapper, pass rest to main
			break
			;;
	esac
	shift
done

SRC_DIR="$(dirname "$0")"
PWD_DIR="$PWD"
RUN_DIR="/"
[ -n "$PREFIX" ]	|| PREFIX="" # leave blank to default to "/"
[ -n "$SELF" ]		|| SELF="$(basename "$0")"
[ -n "$TMP_DIR" ]	|| TMP_DIR="$PREFIX/tmp"
[ -n "$OPT_FORK" ]	|| OPT_FORK="FALSE"
[ -n "$OPT_VERBOSE" ]	|| OPT_VERBOSE="FALSE"
PIDFILE="${TMP_DIR}/${SELF}.pid"
LOGFILE="${TMP_DIR}/${SELF}.log"



################################################################################
#                            Function definitions                              #
################################################################################

# log function
log() {
	_LOG_TIME_STAMP="$(date +%c)"
	touch "$LOGFILE"
	if [ "$OPT_VERBOSE" = "TRUE" ]
	then
		echo "$_LOG_TIME_STAMP	$*" | tee -a "$LOGFILE"
	else
		echo "$_LOG_TIME_STAMP	$*" >> "$LOGFILE"
	fi
}

# error function
err() {
	OPT_VERBOSE="TRUE"
	log "ERROR:	$*"
	OPT_VERBOSE="FALSE"
	return 1
}

# fatal error function
die() {
	OPT_VERBOSE="TRUE"
	err "FATAL ERROR OCCURED IN PROCESS $$"
	err "$@"
	err "EXITING..."
	exit 1
}

# main function
main() {
	true #no-op
}



################################################################################
#                                Init daemon                                   #
################################################################################

init_daemon() {
	# Init logfile
	{
		echo "Logfile for $SELF - $0"
		echo "PIDFILE:	$PIDFILE"
		echo "LOGFILE:	$LOGFILE"
		echo "PWD_DIR:	$PWD_DIR"
		echo "RUN_DIR:	$RUN_DIR"
	} > "$LOGFILE"

	# Init dirs
	for dir in "$SRC_DIR" "$PWD_DIR" "$RUN_DIR" "$TMP_DIR"
	do
		# enure dirs exist
		mkdir -p "$dir" && continue
		die "Could not create $dir, 'mkdir -p $dir' exited with code $?"
	done
}



################################################################################
#                                  Run daemon                                  #
################################################################################

main_wrapper() {
	init_daemon

	# Change to safe running dir
	cd "$RUN_DIR" || die "Could not enter RUN_DIR"

	# Process PID file
	if [ -f "$PIDFILE" ] ; then
		ps -p "$(cat "$PIDFILE")" >/dev/null 2>&1 && \
			die "PID is still running."
		rm "$PIDFILE"
	fi

	# Create PID file
	echo "$$" > "$PIDFILE" || die "Could not create PID file"

	# call main
	if [ -z "$EXEC_CMD" ]
	then
		log "$( \
				main "$@" 2>&1 ; \
				log "main() {...} completed with exit code $?" \
			)"
	else
		[ -x "$(command -v "$(\
					echo "$EXEC_CMD" | \
					awk '{print $1}' ; \
				)")" \
			] || die "$EXEC_CMD is an invalid command"

		log "$( \
				sh -c "$EXEC_CMD" 2>&1 ; \
				log "$EXEC_CMD completed with exit code $?" \
			)"
	fi

	# Remove PID file
	rm -f "$PIDFILE" || die "Could not remove PID file."
}

case "$OPT_FORK" in
	"TRUE") # fork main()
		( main_wrapper "$@" </dev/null >/dev/null 2>&1 & ) &
		;;
	"FALSE") # don't fork main()
		main_wrapper "$@"
		;;
	*) # unreachable
		die "$OPT_FORK is invalid value for boolean OPT_FORK"
		;;
esac

# exit success
exit 0

