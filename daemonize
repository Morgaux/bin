#!/bin/sh

# https://gitlab.com/morgaux/bin
# @Author:	Morgaux Meyer
# @License:	MIT (C) 2019

##
# A UNIX Daemon template in pure Shell
#
# Although included in the ~/bin directory, it is written in pure sh and has no
# dependencies on the other scripts in this repository. This template allows any
# arbitrary .sh script to be used as a daemon, simply by placing the contents
# in the main function. This can even be automated with sed to create a copy
# with the main function filled out. Although, helper functions would need to be
# declared out side of the main().
#
# Obviously, there are many considerations when writing a script or program that
# is run silently in the background. While this template attempts to address as
# many of these as possible, the primary goal is to be POSIX compliant, so that
# any existing script can be easily modified, and so that new scripts can be
# written as freely as possible.
#
# Corruptly, this template allows for logging all output from main, as well as
# Logging explicit messages and even errors. A PID file is used to prevent
# Multiple daemons running if the have the same name, however, if an daemonized
# process is abruptly ended or killed without first removing the PID file a new
# process can still open and will clean the PID. The process will cd into the /
# directory after initializing, so that all main() code is run in the file system
# root. This prevents file systems and directories from getting locked by the
# running process, e.g. to unmount a storage device.
#
# The main function is left very open and free, and so still requires the author
# to be aware of possible issues that can arise if running in the background.
# Most daemons will block STDIN preventing the process from hanging while waiting
# for user input. Although this is wise, it restricts the use of the author to
# read from input. For this reason, the author is encouraged, but not required,
# to refrain from using STDIN for input from the user/controlling process.
#
# As the main function may contain a single line or thousands, error handling
# and recovery is left to the author. The log, err, and die included functions
# allow for consistent implementations. Log() will write a message to the given
# log file. Err() will clearly log an error message and always return a non zero
# success code for failure pipelines. Die() will kill the daemon in the case of
# an unrecoverable error, an clearly log the cause. These functions may be used
# and modified per implementation, however, the serve as a basis on which one
# can build a robust daemon program.
#
# In keeping with the Suckless Philosophy, all configuration is maintained in
# the source code, however, in contrast, there is no config.sh file. Any minor
# behavioural or functional changes should be added to the configuration section
# as local scope variables. This makes making small changes, such as where the
# log file should be, simple to make and understand.
##



################################################################################
#                              Configuration vars                              #
################################################################################

PREFIX="" # leave blank to default to "/"
SELF="$(basename "$0")"
SRC_DIR="$(dirname "$0")"
PWD_DIR="$PWD"
RUN_DIR="/"
TMP_DIR="$PREFIX/tmp"
PIDFILE="${TMP_DIR}/${SELF}.pid"
LOGFILE="${TMP_DIR}/${SELF}.log"
OPT_FORK="TRUE"
OPT_VERBOSE="FALSE"



################################################################################
#                            Function definitions                              #
################################################################################

# log function
log() {
	_LOG_TIME_STAMP="$(date +%c)"
	touch "$LOGFILE"
	if [ "$OPT_VERBOSE" = "TRUE" ]
	then
		echo "$_LOG_TIME_STAMP	$*" | tee -a "$LOGFILE"
	else
		echo "$_LOG_TIME_STAMP	$*" >> "$LOGFILE"
	fi
}

# error function
err() {
	_TMP_OPT_VERBOSE="$OPT_VERBOSE"
	OPT_VERBOSE="TRUE"
	log "ERROR: $*"
	OPT_VERBOSE="${_TMP_OPT_VERBOSE}"
	return 1
}

# fatal error function
die() {
	OPT_VERBOSE="TRUE"
	err "FATAL ERROR OCCURRED IN PROCESS $$"
	err "$@"
	err "EXITING..."
	exit 1
}

# main function
main() {
	true #no-op
}



################################################################################
#                                Init daemon                                   #
################################################################################

init_daemon() {
	# Init log file
	{
		echo "Log file for $SELF - $0"
		echo "PIDFILE:	$PIDFILE"
		echo "LOGFILE:	$LOGFILE"
		echo "PWD_DIR:	$PWD_DIR"
		echo "RUN_DIR:	$RUN_DIR"
	} > "$LOGFILE"

	# Init dirs
	for dir in "$SRC_DIR" "$PWD_DIR" "$RUN_DIR" "$TMP_DIR"
	do
		# inure dirs exist
		mkdir -p "$dir" && continue
		die "Could not create $dir, 'mkdir -p $dir' exited with code $?"
	done
}



################################################################################
#                                  Run daemon                                  #
################################################################################

main_wrapper() {
	init_daemon

	# Change to safe running dir
	cd "$RUN_DIR" || die "Could not enter RUN_DIR"

	# Process PID file
	if [ -f "$PIDFILE" ] ; then
		ps -p "$(cat "$PIDFILE")" >/dev/null 2>&1 && \
			die "PID $(cat "$PIDFILE") is still running."
		rm "$PIDFILE"
	fi

	# Create PID file
	echo "$$" > "$PIDFILE" || die "Could not create PID file"

	# call main
	main "$@" >> "$LOGFILE" 2>&1
	log "main() {...} completed with exit code $?"

	# Remove PID file
	rm -f "$PIDFILE" || die "Could not remove PID file."
}

case "$OPT_FORK" in
	"TRUE") # fork main()
		( main_wrapper "$@" </dev/null >/dev/null 2>&1 & ) &
		;;
	"FALSE") # don't fork main()
		main_wrapper "$@"
		;;
	*) # unreachable
		die "$OPT_FORK is invalid value for boolean OPT_FORK"
		;;
esac

# exit success
exit 0

